<meta charset="utf-8">
<!-- Markdeep: https://casual-effects.com/markdeep/ -->
**LR(0) Automatons and the SLR parsing**
               2022.8.21

Historically, the LR parsing method first came out, then the LL method. [Knuth(1965)](https://harrymoreno.com/assets/greatPapersInCompSci/2.5_-_On_the_translation_of_languages_from_left_to_right-Donald_E._Knuth.pdf) mentioned that Paul had given a general method in 1962 to build a parser that scans from left to right for very simple LR(1) grammar. Knuth introduced LR(k) grammar in the same paper, as well as its definition, method to check whether a grammar is LR(1), and things like how to generate an LR(k) grammar recognizer. The "canonical LR parsing table" introduced in popular compiler textbooks nowadays just comes from there. 

That technique, however, was not easy to implement in the 1960s - since memories in those years were too small to hold big parsing tables generated by it. Four years later, [Konrenjak (1969)](https://dl.acm.org/doi/pdf/10.1145/363269.363281) improved Knuth's method by compressing the size of parsing tables, making LR(k) parsing slightly realistic. DeRemer described LALR parsing in his [Ph.D. thesis](http://publications.csail.mit.edu/lcs/pubs/pdf/MIT-LCS-TR-065.pdf) in the same year. Two years later, he published [SLR parsing method](https://dl.acm.org/doi/pdf/10.1145/362619.362625) according to research done during his writing Ph.D. thesis. That's how these well-known parsing methods come out - they didn't appear in the same order as they are presented in the Dragon Book!

The Dragon Book mentioned that the SLR parsing method is a good start for learning LR parsing. If you have read the papers listed above, you might have found that it's true... So I start my introduction of bottom-up parsing from the SLR method, then extend it to LR(1), LALR, and so on. 

# The LR(0) Item and the LR(0) Automaton
An LR(0) item ("item" for short) is a production with a dot at some position in its body. Set of LR(0) items is called "canonical LR(0) set" ("item set" for short). Here's an example:

$$
\begin{align*}
S &\rightarrow C\ C\\
C &\rightarrow c\ C\\ 
&\;\; | \quad d
\end{align*}
$$

The above grammar has three productions. According to the previous definition, "S → · C C", "C → · c C" and "C → · d" are all LR(0) items. Their set is called an item set. Intuitively, symbols at the right of the dot are what we haven't processed yet, but wish to see next; those at the left of the dot are those we have processed.

How does the LR parser know when to reduce and when to shift? It can just determine the next action according to the state of the LR automaton. We know that the finite automaton used to match strings consists of an alphabet, an initial state, a final state, a state transition function, and several states; the composition of an LR automaton is similar to it - except that its "alphabet" is All terminal symbols and non-terminal symbols in a specific grammar, the state replaced by a specific item set, and the state transition function is just a GOTO function.

# Item Sets and How to Construct Them
To get all item sets, we need to find the initial item set of the LR(0) automaton first. But how to get the initial state? Before answering this question, we define "augmented grammar": If some grammar G starts with the symbol "S", then its augmented grammar G' is all productions in G with a new production "S' → S".  For instance, the augmented grammar of the above simple grammar is:

$$
\begin{align*}
S' &\rightarrow S\\
S &\rightarrow C\ C\\
C &\rightarrow c\ C\\ 
&\;\; | \quad d
\end{align*}
$$

Then define "the closure of an item set":  

For some item set $I$, first copy all its items to $\mathrm{CLOSURE}(I)$. Then, iterate through every item in $\mathrm{CLOSURE}(I)$. If a nonterminal happens to be on the right of the dot of a production, place dots on the leftmost side of all production bodies corresponding to this nonterminal and add them to $\mathrm{CLOSURE}(I)$. Walk through $\mathrm{CLOSURE}(I)$ repeatedly until no more item is added to it. Thus closure of I is constructed.  

Now we can construct the initial state. At first, there's only one set in it:  

$$
\begin{align*}
S' &\rightarrow \; ·\;S\\
\end{align*}
$$

A nonterminal is next to the dot, so it is extended and newly generated items go into the item state:  

$$
\begin{align*}
S' &\rightarrow \; ·\;S\\
S &\rightarrow \; ·\;C \ C\\
\end{align*}
$$

There's still a nonterminal to the right of the dot. So extend nonterminal C:  

$$
\begin{align*}
S' &\rightarrow \; ·\;S\\
S &\rightarrow \; ·\;C \ C\\
C &\rightarrow \; ·\;c \ C\\
C &\rightarrow \; ·\;d
\end{align*}
$$

Now the initial state of the LR(0) automaton is gotten - no need to add new items to the set since we only get repeated items. But how to induce other states? We'll use the GOTO function to do this.

# The GOTO Function
We know that there's something called a state transition function in finite automaton used for string matching and the GOTO function plays a similar role as it. It takes two arguments, one of which is some item set, and the other is a symbol in a grammar which can be terminal, nonterminal, or eof. So how can the GOTO function be used to construct new item sets?  

For some item set $I$ and grammar symbol $X$, we use the following method to construct $\mathrm{GOTO}(I, X)$:  

1. Let I' be an empty new item set.
2. Walk through all items in I, then check if $X$ is to the right of the dot.
3. If that's true, copy that item, shift the dot to the right by one place and drop the processed item to I'.
4. return $\mathrm{CLOSURE}(I')$ after the iteration is done.

We've got the initial item set:  

$$
\begin{align*}
S' &\rightarrow \; ·\;S\\
S &\rightarrow \; ·\;C \ C\\
C &\rightarrow \; ·\;c \ C\\
C &\rightarrow \; ·\;d
\end{align*}
$$

Denote the item set as $I_0$. Newly constructed $\mathrm{GOTO}(I_0, C)$ appears as below and we denote it as $I_1$:  

$$
\begin{align*}
S &\rightarrow \; C\;· \ C\\
C &\rightarrow \; ·\;c \ C\\
C &\rightarrow \; ·\;d
\end{align*}
$$

The copied item is $S \rightarrow \; ·\;C \ C$ - its dot has been shifted by one place to the right and then items in $\mathrm{CLOSURE(C)}$ have been added to the set.  
To construct all item sets of the grammar, we need to construct $\mathrm{GOTO}(I_0, S)$, $\mathrm{GOTO}(I_0, c)$, $\mathrm{GOTO}(I_0, d)$, $\mathrm{GOTO}(I_1, S)$ until GOTO doesn't return a new item set. The set of item sets returned by GOTO and the initial set is called canonical LR(0) collection. Each item set in this collection corresponds to a state in LR(0) automaton. We can transit from state to state by referencing the return value of the GOTO function.  
Following the method described above, the LR(0) automaton of the grammar mentioned at the beginning appears like this:  
  
![](final.jpg)
  
Notice the accepting state in the figure. The whole string becomes acceptable if production S' → S is to be reduced and eof is the next input symbol.  

Although for a small grammar (like the one mentioned in this post) you can deduce its LR(0) automaton by hand, it's such a torment to do so for a slightly bigger one. Thus the construction of LR(0) automatons is usually done automatically.  

# Construct the SLR Parsing Table
SLR parsing table is constructed based on the LR(0) automaton above. We know that the SLR table consists of an action table and a goto table. It takes three steps to construct the action table:  

1. Construct canonical LR(0) collection.
2. Iterate through item sets $I_0, I_1, I_2, \cdots, I_n$ in the collection. For each item set $I_i$, iterate through every LR(0) item in it:
   + if terminal $a$ is at the right of the dot and $\mathrm{GOTO}(I_i, a) = I_j$, set Action[*i*, *a*] to *shift j*.
   + if the dot is at the rightmost position of the item (for example, $A \rightarrow \alpha \; ·$ ), and $A$ is not the start symbol of the augmented grammar (S' for example), for all $a$ in $A$'s follow set, set Action[*i*, *a*] to *reduce i*.
   + if the item is $S' \rightarrow S\; ·$, set Action[*i*, *eof*] to *accept*.

It's simpler to construct a Goto table: for all nonterminals $A$ in a grammar, if $\mathrm{GOTO}(I_i, A) = I_j$, set GOTO[*i*, *A*] to *j*. That's all about constructing Goto tables and Action tables.  
  
According to the methods above, we can construct an SLR parsing table like this:  

| State | Action                       | Action                             |    Action    | Goto | Goto  | Goto  |
|:----:|:----------------------------:|:----------------------------:|:------:|:----:|:-:|:-:|
|      | c                            | d                            | eof    | S'   | S | C |
| 0    | shift 4                      | shift 3                      |        |      | 1 | 2 |
| 1    |                              |                              | accept |      |   |   |
| 2    | shift 4                      | shift 3                      |        |      |   | 5 |
| 3    | reduce $C \rightarrow d$     | reduce $C \rightarrow d$     |        |      |   |   |
| 4    | shift 4                      | shift 3                      |        |      |   | 6 |
| 5    |                              |                              |        |      |   |   |
| 6    | reduce $C \rightarrow c \;C$ | reduce $C \rightarrow c\; C$ |        |      |   |   |

<!-- fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300;0,400;0,600;1,300;1,400&display=swap" rel="stylesheet">

<!-- Markdeep: https://casual-effects.com/markdeep/ -->
<link rel='stylesheet' href='../../css/style.css'>
<script>markdeepOptions={tocStyle:'none'};</script>
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style>
<script src="../../js/markdeep.min.js"></script>
<script src="https://morgan3d.github.io/markdeep/latest/markdeep.min.js"></script>
<script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>